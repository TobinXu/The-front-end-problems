//查找字符串中是否含有某个字符
//方法一
//indexOf()可返回指定的字符串值在字符串中首次出现的位置，如果没有，返回-1
var str = "abc";
console.log(str.indexOf("abc") != -1);

//方法二 search() 用于检索字符串中指定的字符串，或检索与正则表达式相匹配的子字符串
//如果没有返回-1
var str = "1234";
console.log(str.search("3") != -1);

//方法三 match()可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配
var str = "123";
var reg = RegExp(/3/);
if(str.match(reg)) {
    console.log("成功！");
}
console.log(str.match(reg))  //成功返回[ '3', index: 2, input: '123', groups: undefined ]，  失败返回null


// replace 第一个参数为替换目标，第二个参数为要被替换对象
var str ="Visit Microsoft!";
console.log(str.replace(/Microsoft/,"W3School"));

//返回最后一次字符出现的位置，没有的话返回-1
var str = "The full name of Chian is the Prople's Republic of China.";
console.log(str.lastIndexOf("China"));

// slice()提取字符串的某部分，两个参数 开始和结束
//substring() 类似于 slice()。不同之处在于 substring() 无法接受负的索引。
var str = "Apple, Banana,Mango";
console.log(str.slice(7,13));

// substr()类似于slice，不同之处是第二个参数表示要提取部分的长度
var str = "Apple, Banana,Mango";
console.log(str.substr(7,6))

// 大小写转化 toUpperCase(),toLowerCase()
var str = "Apple, Banana,Mango";
console.log(str.toUpperCase());
console.log(str.toLowerCase());

//连接两个字符串
var text1 = "Hello";
var text2 = "en";
var text3 = text1.concat(" ",text2);
console.log(text3);


//删除字符串两端空白符
var str = "     Hello World!     ";
console.log(str.trim());

//返回字符串中指定位置的字符串
var str = "HELLOWORLD";
console.log(str.charAt(0));

//charCodeAt()返回字符串中指定索引的字符的unicode编码
var str = "HELLOWORLD";
console.log(str.charCodeAt(0));

//将字符串转换为数组
var str = "a,b,c,d,f";
console.log(str.split(",")); //[ 'a', 'b', 'c', 'd', 'f' ]
console.log(str.split(" ")); // [ 'a,b,c,d,f' ]
console.log(str.split("|")); // [ 'a,b,c,d,f' ]

// let相比var 没有变量提升，有暂时性死区：没有声明不能使用。let只在代码块内有效

// 匿名函数模仿块级作用域
(function() {
    //这里是块级作用域
})();
 
// 关于匿名函数的讲解
var count = 5;
outputNumbers(count);
// 等同于
outputNumbers(5);
// 演化一下

var someFunction = funciton() {
    // 这里是块级作用域
};
//调用执行方法
someFunction();
//等同于
(function() {
    //块级作用域
})();

20200601
// symbol 作为一个对象或一个Map的键值，他可以保证你的对象或Map键值不重复。
var privateKey = Symbol();
var obj = {
    [privateKey] : 'Hero'
}
// 访问时
console.log(obj[privateKey]); //Hero

// 数据结构Set，类似于数组，成员的值都是唯一的，没有重复值
const s = new Set();
[2,3,5,4,2,2].forEach(x => s.add(x));
for (let i of s) {
    console.log(i);
}
// 去除数组的重复成员
[...new Set(Array)]

const set = new Set([1,2,3,4,4]);
[...set]


// JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制
// Map 数据结构，各种类型的值（包括对象）都可以当键。
// Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。
const m = new Map();
const o = {p: 'Hello World'};
m.set(o, 'content');
m.get(o); // 'content'
m.has(o) //true
m.delete(o)
m.has(o) // false

// 在实现一次
const map = new Map([
    ['name', '张三'],
    ['title', 'Author']
]);
map.size // 2
map.has('name') //true
map.get('name') // 张三
map.has('title') //true
map.get('title') //Author


// 居中
// div使用绝对布局
1.设置margin:AudioTrack;并设置top,left,right,bottom的值都相等。
2.设置left和top都是50%，然后再用transform(-50%, -50%) 向左平移它的宽度的50%
// div使用flex布局
设置justify-content:center; // 水平居中
align-items:center; //垂直居中


// 伪类和伪元素
在css3中使用单冒号来表示伪类，用双冒号来表示伪元素。但是为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号
来表示伪元素。

伪类一般匹配的是元素的一些特殊状态，如hover、link等，而伪元素一般匹配的特殊的位置，比如after、before等


// 选择器
（1）id选择器（#myid）
（2）类选择器（.myclassname）
（3）标签选择器（div,h1,p）
（4）后代选择器（h1p）
（5）相邻后代选择器（子）选择器（ul>li）
（6）兄弟选择器（li~a）
（7）相邻兄弟选择器（li+a）
（8）属性选择器（a[rel="external"]）
（9）伪类选择器（a:hover,li:nth-child）
（10）伪元素选择器（::before、::after）
（11）通配符选择器（*）

// div嵌套div ，点击子级div不触发父级div点击事件
解决方法： 在子级div上增加一个事件 onClick="event.cancelBubble = true"，这样就可以只触发自身的点击事件了
 或者在孩子事件里面声明event.stopPropagation();//终止事件冒泡

在父div的position为abosulte或是relative的情况下，子级div的position为absolute.
此时监听到了父div的缩放，并触发了事件。
那么js如何做到去操作子级的left和top，及width和height，随着父div的缩放而自适应呢？
.a{
    width: 500px;
    height: 500px;
    position:relative;
    border: 1px solid red;
  }
  .b{
    width: 10%;
    height: 10%;
    position: absolute;
    left: 10%;
    top: 10%;
    border: 1px solid green;
  }

<div class="a">
  <div class="b"></div>
</div>



// 冒泡学习
<div id="outer">
    <p id="inner">Click me!</p>
</div>
事件冒泡微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，
泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。
因此上面的例子在事件冒泡的概念下发生click事件的顺序应该是p -> div -> body -> html -> document

// 事件捕获
网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：
element.addEventListener(event, function, useCapture) // useCapture 设置为 true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）
//                                            false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）

// cookie和session  cookie通过在客户端记录信息确定用户身份（不可跨域），session通过在服务端记录信息确定用户身份
http是一种无状态协议，一旦数据交换完毕，客户端和服务端就会断开连接，再次交互数据需要重新建立连接。
cookie可以解决上面问题，服务器如果徐涛记录该用户状态，就使用response向客户端办法一个cookie，
当客户端会把cookie保存起来，需要请求时，将请求网址和cookie一同提交给服务器，服务器进行辨认。

session相当于在服务器上面建立一份客户档案，客户来访的时候只需要查询客户档案表即可。
session机制决定了客户只能获取到自己的session，彼此独立，互不可见。
提高速度》内存里，客户第一次访问创建，生成后只要用户访问就更新维护。超过超时时间失效。
生命周期：session浏览器启动关闭，session消失，而cookie预先设置生存周期，或永久保存到本地文件。


